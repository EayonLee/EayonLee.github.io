[{"content":"前言 随着我们日常生活工作中需要再电脑上存储的数据量不断增多。如一个3A大作，上百G都不足为奇，蓝光4K超清资源，一部也有70/80G。存储空间不够了怎么办？买硬盘。OK！硬盘到手了，但每个硬盘各有一个分区，七八个盘符看着就闹心。比较重要的数据，想要保险点，还要手动备份到另一块硬盘。如何能够充分利用，多硬盘的优势呢？那就不得不提下磁盘阵列（RAID），一起来了解下～\n1、什么是 RAID RAID（Redundant Array of Independent Disks，独立磁盘冗余阵列）\n其主要核心是把多块独立的磁盘，组成成一个容量巨大的磁盘组，且通过冗余存储提高容错能力。\n2、RAID 物理分类 RAID在物理层面主要分为：软RAID和硬RAID\n2.1、硬RAID 由图可见硬RAID主要有两种方式：\n**阵列柜：**价格较贵，一般用于企业级应用。\n**阵列卡：**价格便宜，适用于普通用户。市面上大部分阵列卡有缓存，可以提升读写速度，且可通过阵列卡中的电池在意外断电的情况下保持缓存中的数据，等供电恢复时再继续写入。\nPS：千万不要尝试使用主板RAID功能，一旦主板要是出现超频失败、电池没电等问题都非常容易导致阵列信息丢失\n硬RAID主要是由专门的RAID控制器来实现RAID功能，且硬RAID通常比软RAID的性能要好，这是因为硬RAID控制器具有专用的处理器和内存，并且不会受到操作系统的负载和其他应用程序的干扰，而软RAID的性能则取决于CPU和操作系统的负载。\n2.2、软RAID 软RAID是通过操作系统和软件来实现RAID功能，它并不想硬RAID的一样有独立的控制器，所以早期的软RAID并不稳定，速度也不及硬RAID，但随着技术不断优化，软硬RAID的差距也就不那么明显了。像大家常见的NAS中通常都是软RAID。\n3、常用 RAID 级别 RAID 是一种通过将多个磁盘组合起来形成一个逻辑硬盘的技术。而且RAID可以分为不同的级别，每个级别具有不同的数据保护和性能特征。\n主要分为标准 RAID（RAID 0 ~ RAID 6）、混合 RAID（JBOD、RAID 7、RAID 10/0、RAID 50 等）\n3.1、RAID 0 RAID0 是一种非常简单的方式，比如我们拿2块磁盘使用RAID0级别。当写入数据时会将一条数据分为不相同的2份，这2份数据会并发的写入到2块磁盘中，相当于每个磁盘存储了一条数据的一半，并不会进行数据的冗余备份，因此读写性能非常高。\n但也正因为它不会对数据校验或冗余备份，因此一旦某块磁盘坏了，数据就直接丢失无法恢复。\nRAID0至少需要两块磁盘，可以使用任意数量的磁盘。每个磁盘的容量不必相同，但是最终的磁盘阵列容量等于最小容量的磁盘乘以磁盘数量。例如：有3块磁盘，分别为500GB、1TB、2TB，那么RAID0的容量为500GB*3=1.5TB\n那有没有可以让存储可靠性变高的方案呢？那就是下面的RAID1\n3.2、RAID 1 RAID1简单理解就是将数据完全备份到另一个磁盘上，也成为镜像。它的有点时可以提高数据的安全性和可靠性，因为每个磁盘都有一份完整的数据副本。如果某个磁盘出现故障，其他硬盘仍然可以正常工作，数据不会丢失。但是缺点就在于降低了存储空间利用率和写入性能，因为每写入一条数据就要无差别的写入到所有磁盘当中。\nRAID1至少需要2块磁盘，可以使用任意偶数数量的磁盘。每个磁盘的容量不必相同，但是最终的磁盘阵列容量等于最小容量的磁盘。例如：如果有4块磁盘，分别为500GB、1TB、2TB和4TB，那么RAID1的磁盘阵列总容量未500GB。\n3.3、RAID5 RAID5因为存储性能、数据安全、存储成本都兼顾，所以是目前使用较多的一种级别。\n在了解RAID5之前，我们可以简单看一下RAID3，虽然RAID3用的很少，但清楚了3就很容易明白5的思路。\nRAID3的方式是：将数据按照RAID0的形式，分成多份然后并发写入多块磁盘，但是还会额外留出一块磁盘用于写奇偶校验码。例如总共有3块磁盘，那么就会让其中2块磁盘来并发的写入数据，第3块磁盘用来记录奇偶校验码。当某块数据盘坏掉时可以通过校验盘对数据进行恢复。\n但由于每写入一条数据都需要去更新校验盘，所以就会导致校验盘的负载较高，也就非常容易损坏。当校验盘损坏了也就无法进行数据恢复了。\nRAID5的方式可以说是对RAID3进行了改进。在RAID5的模式中，不需要单独用一个磁盘记录奇偶校验码，它会把奇偶校验码分布在各个磁盘中。例如，总共有3块磁盘，那么会将要写入的数据分成3份，并发写入3块磁盘中，同时还将数据的奇偶校验码信息也写入到这3块磁盘中（数据对应的校验码必须存储在不同的磁盘上）。一旦某一块磁盘损坏，就可以通过剩下的磁盘中的校验码信息进行数据恢复。\nRAID5校验位算法原理：P = D1 xor D2 xor D3 … xor Dn （D1,D2,D3 … Dn为数据块，P为校验，xor为异或运算）\nRAID5的方式，最少需要三块磁盘来组建磁盘阵列，允许最多同时坏一块磁盘。如果有两块磁盘同时损坏了，那数据就无法恢复了。\nRAID5可以使用任意数量的硬盘。每个硬盘的容量不必相同，但是最终的磁盘阵列容量等于最小容量的硬盘乘以硬盘数量减一。例如，如果有五块硬盘，分别为500GB、1TB、2TB、3TB和4TB，那么RAID5的容量为500GB x (5 - 1) = 2TB。\n3.4、RAID6 为了进一步提高存储的高可用，大佬们又提出了RAID6方案，可以在有两块磁盘同时损坏的情况下，也能保障数据可恢复。\n为什么RAID6这么牛呢，因为RAID6在RAID5的基础上再次改进，引入了双重校验的概念。\nRAID6除了每块磁盘上都有同级数据XOR校验区以外，还有针对每个数据块的XOR校验区，这样的话，相当于每个数据块有两个校验保护措施，因此数据的冗余性更高了。\n但是RAID6的这种设计也带来了很高的复杂度，虽然数据冗余性好，读取的效率也比较高，但是写数据的性能就很差。因此RAID6在实际环境中应用的比较少。\n3.5、RAID10 RAID10是一种将RAID1和RAID0结合起来的方法，也称为镜像条带化（mirrored striping）。\n比如我们现在有4个磁盘，将4个磁盘分为两组（每组2个磁盘），当我们写入一条数据的时候首先会基于RAID0将一条数据分为不相同的2份，这2份数据会并发的写入到2组磁盘中，相当于每组磁盘存储了一条数据的一半。此时再每组磁盘的基础上使用RAID1，将这条数据的一半并发写入到当前磁盘组的所有磁盘中进行冗余备份。\n但也可以看出RAID10模式是有一半的磁盘空间用于存储冗余数据的，浪费的很严重，因此用的也不是很多。\n4、总结 RAID级别 最少磁盘数 容量公式 优点 缺点 RAID0 2 N*S 高速读写 无冗余备份，可靠性低 RAID1 2 S 数据可靠 空间利用率低 RAID5 3 (N - 1) * S 平衡 写性能低 RAID10 4 (N / 2) * S 高速且高可靠 空间利用率低 ","permalink":"https://eayonlee.com/tech/storage/raid%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/","summary":"前言 随着我们日常生活工作中需要再电脑上存储的数据量不断增多。如一个3A大作，上百G都不足为奇，蓝光4K超清资源，一部也有70/80G。存储空间不够了怎么办？买硬盘。OK！硬盘到手了，但每个硬盘各有一个分区，七八个盘符看着就闹心。比较重要的数据，想要保险点，还要手动备份到另一块硬盘","title":"RAID磁盘阵列"},{"content":"1 简介 Supervisor是用Python开发的一套通用的进程管理工具，能将一个普通的命令行变为后台Daemon，并监控进程状态，异常退出时能自动重启。是通过 fork/exec 的方式把这些被管理的进程当作Supervisor的子进程来启动，这样只要在Supervisor的配置文件中，把要管理的进程可执行文件的路径写进去即可。\nSupervisor主要分为以下四个核心部分：\nSupervisord：它是Supervisor服务的主要管理器，运行Supervisor时会启动一个进程Supervisord，它负责启动所管理的进程；并将所管理的进程作为自己的子进程来启动，而且可以在所管理的进程出现崩溃时自动重启 Supervisorctl：这是Supervisor服务的客户端命令行工具，可以用来执行stop、start、restart等命令来对这些子进程进行管理 Web Server：这是Supervisor服务的网页可视化界面，可以通过Web界面查看和控制进程状态，简化了对操作命令的学习 xml-rpc interface：服务于Web UI的同一个HTTP服务器，提供一个xml-rpc接口，可以用来查询和控制管理程序及其他运行的程序 官网：www.supervisord.org。\n2 Supervisor服务运行环境说明 Supervisor可以运行在大多数泪Unix系统，但是不能运行在任何Windows系统，Supervisor运行在Python环境中，可以在Python2和Python3版本上工作。\n3 Supervisor 安装 由于我是Ubuntu系统所以这里使用apt的方式，CentOS自行使用yum\n当然你也可以通过安装python-pip，然后通过pip install supervisor来安装Supervisor也是没问题的\n# 安装 sudo apt update \u0026amp;\u0026amp; sudo apt install supervisor # 验证 sudo systemctl status supervisor supervisord -version 4 配置进程管理 Supervisor安装完成之后会在系统中生成两个主要的配置文件：\n主进程配置文件：/etc/supervisor/supervisord.conf\n子进程配置文件目录：/etc/supervisor/conf.d/\n注意：如果你是用pip方式安装的Supervisor，默认是没有主进程和子进程配置文件的，但你可以通过echo_supervisord_conf \u0026gt; /etc/supervisor/supervisord.conf命令生成一个主进程配置文件，然后通过mkdir /etc/supervisor/conf.d生成一个子进程配置文件目录\n4.1 Supervisord 配置及启动 如下为完整的supervisord.conf配置文件\n;开头的代表注释，有可能你默认的配置文件和下面的不一样，你可以按照下面的配置进行相应的增加，如下是4.1.0版本完整配置\n有些路径配置尽量保持你默认配置不要修改\n[unix_http_server] file=/var/run/supervisor.sock ; socket套接字文件的路径，用于客户端和服务端建立本地连接 chmod=0700 ;socket文件的权限，默认是0700 ;chown=nobody:nogroup ;socket文件属主与属组信息设定，格式：uid:gid，注释掉使用默认就行 ;[inet_http_server] ;Web界面配置，默认是没有的（关闭），一般企业里使用也不打开 ;port=127.0.0.1:9901 ;Web管理后台运行的IP和端口，如果开放到公网切部署在云服务器，这里应该是内网ip ;username=user ;登录管理后台的用户名 ;password=123 ;登录管理后台的密码 [supervisord] logfile=/var/log/supervisor/supervisord.log ;主日志文件;默认为$CWD/supervisor.log logfile_maxbytes=50MB ;日志文件大小，超出会rotate，默认50MB，如果设置成0表示不限制大小 logfile_backups=10 ;主日志文件的备份数量，默认是10，设为0表示不备份 loglevel=info ;日志级别，默认为info,其它值为“debug,warn,trace” pidfile=/var/run/supervisord.pid ;supervisord服务进程pid文件，如果没有改文件也就说明supervisord没有运行 nodaemon=false ;是否在前台启动，默认是false，即以daemon（后台）的方式启动 minfds=65536 ;可以打开的文件描述符的最小值，默认 1024，企业中可以调整到最大65536 minprocs=200 ;可以打开的进程数的最小值，默认 200,企业中默认200够用 ;如下全部注释掉，一般也不使用，需要时可按需打开 ;umask=022 ; (process file creation umask;default 022) ;user=chrism ; (default is current user, required if root) ;identifier=supervisor ; (supervisord identifier, default is \u0026#39;supervisor\u0026#39;) ;directory=/tmp ; (default is not to cd during start) ;nocleanup=true ; (don\u0026#39;t clean up tempfiles at start;default false) ;childlogdir=/tmp ; (\u0026#39;AUTO\u0026#39; child log dir, default $TEMP) ;environment=KEY=value ; (key value pairs to add to environment) ;strip_ansi=false ; (strip ansi escape codes in logs; def. false)[supervisorctl] [rpcinterface:supervisor] ;用于外部程序或工具通过rpc接口与 Supervisor 通信和控制被监控的进程。比如supervisorctl，一定要添加，不然supervisorctl用不了 supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface [supervisorctl] serverurl=unix:///var/run/supervisor.sock ; supervisorctl通过socket连接supervisord服务端，路径需要和与unix_http_server中的file一致，该方式也就是通过本地的方式连接 ;如果你想通过网络http的方式可以使用下面的配置，但是下面和上面的serverurl不能共存，切记 ;serverurl=http://127.0.0.1:9001 ;通过HTTP的方式连接supervisord ;username=chris ; should be same as http_username if set ;password=123 ; should be same as http_password if set ;prompt=mysupervisor ; cmd line prompt (default \u0026#34;supervisor\u0026#34;) ;history_file=~/.sc_history ; use readline history if available;[program:xx]是被管理的进程配置参数，xx是进程的名称 [include] files = /etc/supervisor/conf.d/*.ini ;相当于是引入其他的配置文件进来，支持ini和conf，一般program配置我们不会写在当前配置文件中，都会单独写在外面，所以就可以通过include进行引入 修改完配置文件之后先查看是否已启动supervisord，如果启动需要重启加载我们新更新的配置\n# 查看进程 root@bj-ubuntu-eayon:~# ps -ef | grep supervisord root 3463154 1 0 Sep02 ? 00:00:09 /usr/bin/python3 /usr/bin/supervisord -n -c /etc/supervisor/supervisord.conf root 3878074 3876890 0 12:06 pts/0 00:00:00 vim supervisord.conf root 3894307 3893980 0 13:12 pts/2 00:00:00 grep --color=auto supervisord # kill supervisord root@bj-ubuntu-eayon:~# kill -9 3463154 指定supervisord.conf配置文件启动supervisord\nsupervisord -c /etc/supervisor/supervisord.conf 如果出现Unlinking stale socket /var/run/supervisor.sock错误，可以通过sudo rm /var/run/supervisor.sock删除后重试\n启动好之后建议通过ps -ef | grep supervisord查看启动进程，如果出现两个的话讲最旧的进行删除。\n访问Web\n4.2 Program 子进程配置文件 比如我们现在想要通过Supervisor来管理一个Nginx，首先先下载一个Nginx\nsudo apt install nginx # 下载完之后他会默认启动，可以看一下 root@bj-ubuntu-eayon:/opt# systemctl status nginx ● nginx.service - A high performance web server and a reverse proxy server Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled) Active: active (running) since Sun 2023-09-03 14:41:16 CST; 13s ago Docs: man:nginx(8) Main PID: 3936874 (nginx) Tasks: 3 (limit: 2262) Memory: 5.4M CGroup: /system.slice/nginx.service ├─3936874 nginx: master process /usr/sbin/nginx -g daemon on; master_process on; ├─3936875 nginx: worker process └─3936876 nginx: worker process # 那我们先把它给kill掉 root@bj-ubuntu-eayon:/opt# ps -ef | grep nginx root 3936874 1 0 14:41 ? 00:00:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on; www-data 3936875 3936874 0 14:41 ? 00:00:00 nginx: worker process www-data 3936876 3936874 0 14:41 ? 00:00:00 nginx: worker process root 3937378 3893980 0 14:42 pts/2 00:00:00 grep --color=auto nginx root@bj-ubuntu-eayon:/opt# kill -9 3936874 3936875 3936876 Program配置文件就是配置我们要管理的进程的配置文件。当然也可以把下面所有配置项都写到 supervisord.conf 文件里，但并不推荐这样做，而是通过在supervisord.conf中通过include 的方式把不同的程序（组）写到不同的配置文件里。\n由于我们的子进程配置文件目录是/etc/supervisor/conf.d/，所以我们需要在该目录下创建/etc/supervisor/conf.d/nginx.ini\n[program:nginx] ; 当前被管理程序，格式: [program:xxx] 后面的名字可以随意 command=/usr/sbin/nginx -g \u0026#39;daemon off;\u0026#39; ; 程序启动命令，跟手动在命令行启动的命令是一样的 autostart=true ; 当前被管理程序是否随supervisord一起启动 startsecs=10 ; 当前被管理程序启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒，根据具体服务的启动时长进行改变，比如java就比较慢 autorestart=true ; 当前被管理程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启 startretries=1 ; 当前被管理程序启动失败自动重试次数，默认是3 user=root ; 用哪个用户启动当前被管理程序，默认是root priority=999 ; 当前被管理程序启动优先级，默认999，该值最小的优先启动 redirect_stderr=true ; 重定向stderr错误日志到stdout标准日志，默认false，一般都会重定向到一个 stdout_logfile=/var/log/nginx/nginx.log ; 程序运行输出的stdout标准日志文件（正常运行日志），需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录 stdout_logfile_maxbytes=20MB ; stdout 日志文件大小，默认50MB stdout_logfile_backups=20 ; stdout 日志文件备份数，默认是10 ;stderr_logfile=/opt/apache-tomcat-8.5.87/logs/catalina.err ; 程序运行输出的stderr错误日志文件输出路径 ;stderr_logfile_maxbytes=1MB ; stderr 日志文件大小，默认50MB ;stderr_logfile_backups=10 ; stderr 日志文件备份数，默认是10 ;stopasgroup=false ; 默认为false，当前被管理程序被杀死时是否向这个进程组发送stop信号，包括子进程 ;killasgroup=false ; 默认为fakse，当前被管理程序被杀死时是否向这个进程组发送kill信号，包括子进程 切记：配置中的日志输出路径和日志文件一定要提前创建，否则启动失败\n当添加/修改子进程配置之后，可以使用supervisorctl reread进行配置检查，配置无误后通过supervisorctl update更新配置。\n此时在后台就可以直接看见新增的子进程\n5 常用命令介绍 supervisorctl status nginx # nginx状态 supervisorctl stop nginx # 停止nginx supervisorctl start nginx # 启动nginx supervisorctl restart nginx # 重启nginx supervisorctl reoload nginx # 重载nginx supervisorctl update nginx # 配置文件修改后可以使用该命令加载新的配置 # 所有子进程 supervisorctl start all # 启动所有被监控的进程 supervisorctl stop all # 停止所有被监控的进程 supervisorctl restart all # 重启所有被监控的进程 supervisorctl reload all # 重新加载所有被监控的进程的配置 supervisorctl shutdown # 关闭Supervisor # 主要针对supervisord.conf配置文件的刷新，而不需要重启 Supervisor 进程。当修改了supervisord.conf，例如增加或修改了进程配置时，使用 reload 命令可以应用这些更改。重要的是，reload 不会中断已经在运行的进程，只会影响新的配置更改。 supervisorctl reload # 检查supervisord配置和引入的子进程配置文件，如果配置文件没有问题，将显示 xxxxxxx: available supervisorctl reread # 主要针对子进程配置文件的刷新，它关注于管理和操作已定义的进程，而不会重新加载 supervisord.conf 的主配置文件。 supervisorctl update ","permalink":"https://eayonlee.com/tech/linux/supervisor%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/","summary":"1 简介 Supervisor是用Python开发的一套通用的进程管理工具，能将一个普通的命令行变为后台Daemon，并监控进程状态，异常退出时能自动重启。是通过 fork/exec 的方式把这些被管理的进程当作Supervisor的子进程来启动，这样只要在Supervisor的配置文件中，把要管理的进","title":"Supervisor进程管理工具"},{"content":" Eayon\u0026#39;s Blog 一个分享技术、阅读、生活的博客 ","permalink":"https://eayonlee.com/links/","summary":"Eayon\u0026#39;s Blog 一个分享技术、阅读、生活的博客","title":"🤝 Links"},{"content":" section .data name db \u0026#34;Eayon Lee\u0026#34;, 0 prefer_name db \u0026#34;Eayon\u0026#34;, 0 born_year dd 1997 hometown db \u0026#34;Suqian, Jiangsu, CN\u0026#34;, 0 curr_location db \u0026#34;Chaoyang, Beijing, CN\u0026#34;, 0 ","permalink":"https://eayonlee.com/about/","summary":"section .data name db \u0026#34;Eayon Lee\u0026#34;, 0 prefer_name db \u0026#34;Eayon\u0026#34;, 0 born_year dd 1997 hometown db \u0026#34;Suqian, Jiangsu, CN\u0026#34;, 0 curr_location db \u0026#34;Chaoyang, Beijing, CN\u0026#34;, 0","title":"🙋🏻‍♂️ About"}]